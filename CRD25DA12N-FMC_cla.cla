
//#############################################################################
//
// FILE:    CRD25DA12N-FMC_cla.cla (Wolfspeed CRD25DA12N-FMC Control Law
//  Accelerator - WS CRD25DA12N-FMC CLA)
//
// TITLE:   CRD25DA12N-FMC 25 kW Controller Code
//
// AUTHOR:  WOLFSPEED
//
// PURPOSE:
//  Control Law Accelerator (CLA) functions for the Wolfspeed three-phase
//  CRD25DA12N-FMC reference design. Using the CLA to off-load compute
//  resources from the primary CPU.
//
//#############################################################################

//
// Included Files
//
#include <CRD25DA12N-FMC_shared.h>
#include <stdint.h>
#include "libraries/CLAmath/CLAmath.h"

//
// Clarke Transform Constants (3-phase abc -> stationary alpha-beta frame)
//   CLARKE_A  =  2/3          coefficient for phase-A in alpha calculation
//   CLARKE_B  =  1/3          coefficient for phase-B,C in alpha calculation (subtracted in code)
//   CLARKE_C  =  1/sqrt(3)    coefficient for beta calculation
//
#define CLARKE_A    0.6666666667f
#define CLARKE_B    0.3333333333f
#define CLARKE_C    0.5773502692f

//
// Inverse Clarke Constant (alpha-beta -> 3-phase abc)
//   INV_CLARKE_SIN60 = sqrt(3)/2    used in beta contribution to phase-B,C
//
#define INV_CLARKE_SIN60    0.8660254038f

//
// Function Prototypes
//
void updateOpenLoopSinePwmsCla(void);
void updateClosedLoopCurrentPwmsCla(void);
void updateIndividualOpenLoopSinePwmCla(uint32_t base, float epwmIndividualAngle);
void updateIndividualDutyPwmCla(uint32_t base, float phaseDuty);
void updateElectricalAngleCla(void);
void updatePllValidityCla(void);
void computeDqAxisVoltagesCla(void);
void runDqVoltageControllerCla(void);
void runDcVoltageControllerCla(void);
void computeDqAxisCurrentsCla(void);
void runDqCurrentControllerCla(void);
float clampUnitFloatCla(float val);
float clampFloatCla(float val, float low, float high);

//*****************************************************************************
//
//! Control Law Accelerator (CLA) Task 1 function. Configured in SysConfig to
//! trigger when EPWM1 interrupt triggers. Executes PLL/angle selection,
//! voltage/current transforms, control loops, and PWM updates once per
//! switching period to reduce computational burden on CPU.
//!
//! \return None.
//
//*****************************************************************************
__interrupt void Cla1Task1(void) {
    updateElectricalAngleCla();
    updatePllValidityCla();
    computeDqAxisVoltagesCla();
    runDqVoltageControllerCla();
    runDcVoltageControllerCla();
    computeDqAxisCurrentsCla();
    runDqCurrentControllerCla();
    if (controlMode == 0u) {
        updateOpenLoopSinePwmsCla();
    } else {
        updateClosedLoopCurrentPwmsCla();
    }
}

//*****************************************************************************
//
//! Select the electrical angle source:
//!  - open-loop rotating angle from CPU (legacy behavior), or
//!  - SRF-PLL angle estimated from measured phase voltages.
//!
//! \return None.
//
//*****************************************************************************
void updateElectricalAngleCla(void) {
    if ((angleSourceSelect == 0u) && (controlMode != 3u)) {
        electricalAngle = epwmAngles[0];
        return;
    }

    {
        // Clarke transform: 3-phase voltages -> stationary alpha-beta frame
        float vAlpha = CLARKE_A * phaseVoltageU - CLARKE_B * (phaseVoltageV + phaseVoltageW);
        float vBeta  = CLARKE_C * (phaseVoltageV - phaseVoltageW);

        // Park transform of voltage into PLL's estimated rotating frame.
        // CLAsin(x + PI/2) = cos(x) â€” CLA has no native cosine function.
        float sinTheta = CLAsin(pllTheta);
        float cosTheta = CLAsin(pllTheta + PI * 0.5f);
        float omegaErr;

        // q-axis voltage drives the PLL: when locked, Vq -> 0
        pllVq = -vAlpha * sinTheta + vBeta * cosTheta;

        // PI controller on Vq error to estimate grid frequency offset
        pllIntegrator += pllKi * controlPeriodSec * pllVq;
        pllIntegrator = clampFloatCla(pllIntegrator, -2.0f * PI2 * 200.0f, 2.0f * PI2 * 200.0f);

        omegaErr = pllKp * pllVq + pllIntegrator;
        pllOmega = pllOmegaNom + omegaErr;
        pllOmega = clampFloatCla(pllOmega, 2.0f * PI2 * 10.0f, 2.0f * PI2 * 1000.0f);

        // Integrate frequency to get angle, wrap to [0, 2*pi)
        pllTheta += pllOmega * controlPeriodSec;
        if (pllTheta >= PI2)
            pllTheta -= PI2;
        else if (pllTheta < 0.0f)
            pllTheta += PI2;

        electricalAngle = pllTheta;
    }
}

//*****************************************************************************
//
//! Evaluate PLL lock status using q-axis voltage residual and frequency error.
//! Applies debounce/hysteresis counters for robust lock detection.
//!
//! \return None.
//
//*****************************************************************************
void updatePllValidityCla(void) {
    float vqAbs;
    uint16_t pllInUse = ((angleSourceSelect == 1u) || (controlMode == 3u)) ? 1u : 0u;

    if (pllInUse == 0u) {
        pllFreqErrHz = 0.0f;
        pllLockCounter = 0u;
        pllLocked = 0u;
        pllError = 0u;
        return;
    }

    pllFreqErrHz = (pllOmega - pllOmegaNom) / PI2;
    if (pllFreqErrHz < 0.0f)
        pllFreqErrHz = -pllFreqErrHz;

    vqAbs = pllVq;
    if (vqAbs < 0.0f)
        vqAbs = -vqAbs;

    if ((vqAbs <= PLL_LOCK_VQ_ABS_MAX_V) && (pllFreqErrHz <= PLL_LOCK_FREQ_ERR_MAX_HZ)) {
        if (pllLockCounter < PLL_LOCK_COUNT_ON)
            pllLockCounter++;
    } else {
        if (pllLockCounter > 0u)
            pllLockCounter--;
    }

    if (pllLockCounter >= PLL_LOCK_COUNT_ON)
        pllLocked = 1u;
    else if (pllLockCounter <= PLL_LOCK_COUNT_OFF)
        pllLocked = 0u;

    pllError = (pllLocked == 0u) ? 1u : 0u;
}

//*****************************************************************************
//
//! Compute dq-axis currents from sampled phase currents and electrical angle
//! using Clarke + Park transforms.
//!
//! \return None.
//
//*****************************************************************************
void computeDqAxisCurrentsCla(void) {
    // Clarke transform: 3-phase currents -> alpha-beta
    float iAlpha = CLARKE_A * phaseCurrentU - CLARKE_B * (phaseCurrentV + phaseCurrentW);
    float iBeta  = CLARKE_C * (phaseCurrentV - phaseCurrentW);

    // Park transform: alpha-beta -> rotating dq frame
    float sinTheta = CLAsin(electricalAngle);
    float cosTheta = CLAsin(electricalAngle + PI * 0.5f);  // cos(x) = sin(x + pi/2)

    idCurrentMeas =  iAlpha * cosTheta + iBeta * sinTheta;
    iqCurrentMeas = -iAlpha * sinTheta + iBeta * cosTheta;
}

//*****************************************************************************
//
//! Compute dq-axis voltages from sampled phase voltages and selected angle.
//!
//! \return None.
//
//*****************************************************************************
void computeDqAxisVoltagesCla(void) {
    // Clarke transform: 3-phase voltages -> alpha-beta
    float vAlpha = CLARKE_A * phaseVoltageU - CLARKE_B * (phaseVoltageV + phaseVoltageW);
    float vBeta  = CLARKE_C * (phaseVoltageV - phaseVoltageW);

    // Park transform: alpha-beta -> rotating dq frame
    float sinTheta = CLAsin(electricalAngle);
    float cosTheta = CLAsin(electricalAngle + PI * 0.5f);  // cos(x) = sin(x + pi/2)

    vdVoltageMeas =  vAlpha * cosTheta + vBeta * sinTheta;
    vqVoltageMeas = -vAlpha * sinTheta + vBeta * cosTheta;
}

//*****************************************************************************
//
//! Outer voltage loop (optional, active only in cascaded mode).
//! Generates dq current references for inner current loop.
//!
//! \return None.
//
//*****************************************************************************
void runDqVoltageControllerCla(void) {
    if (controlMode != 2u) {
        vdVoltageErr = 0.0f;
        vqVoltageErr = 0.0f;
        vdVoltageIntegrator = 0.0f;
        vqVoltageIntegrator = 0.0f;
        idRefFromVoltageLoop = 0.0f;
        iqRefFromVoltageLoop = 0.0f;
        return;
    }

    vdVoltageErr = vdVoltageRef - vdVoltageMeas;
    vqVoltageErr = vqVoltageRef - vqVoltageMeas;

    vdVoltageIntegrator += voltageKi * controlPeriodSec * vdVoltageErr;
    vqVoltageIntegrator += voltageKi * controlPeriodSec * vqVoltageErr;
    vdVoltageIntegrator = clampFloatCla(vdVoltageIntegrator, -VOLTAGE_LOOP_INT_LIMIT_A, VOLTAGE_LOOP_INT_LIMIT_A);
    vqVoltageIntegrator = clampFloatCla(vqVoltageIntegrator, -VOLTAGE_LOOP_INT_LIMIT_A, VOLTAGE_LOOP_INT_LIMIT_A);

    idRefFromVoltageLoop = clampFloatCla(voltageKp * vdVoltageErr + vdVoltageIntegrator, -VOLTAGE_LOOP_IREF_LIMIT_A, VOLTAGE_LOOP_IREF_LIMIT_A);
    iqRefFromVoltageLoop = clampFloatCla(voltageKp * vqVoltageErr + vqVoltageIntegrator, -VOLTAGE_LOOP_IREF_LIMIT_A, VOLTAGE_LOOP_IREF_LIMIT_A);
}

//*****************************************************************************
//
//! Outer DC-bus loop for active rectifier mode. Generates d-axis current
//! reference to regulate Vdc. q-axis reference is fixed to 0 in current loop.
//!
//! \return None.
//
//*****************************************************************************
void runDcVoltageControllerCla(void) {
    if (controlMode != 3u) {
        vdcVoltageErr = 0.0f;
        vdcVoltageIntegrator = 0.0f;
        idRefFromDcVoltageLoop = 0.0f;
        return;
    }

    vdcVoltageErr = vdcVoltageRef - dcBusVoltageMeas;
    vdcVoltageIntegrator += dcVoltageKi * controlPeriodSec * vdcVoltageErr;
    vdcVoltageIntegrator = clampFloatCla(vdcVoltageIntegrator, -VDC_LOOP_INT_LIMIT_A, VDC_LOOP_INT_LIMIT_A);

    idRefFromDcVoltageLoop = clampFloatCla(dcVoltageKp * vdcVoltageErr + vdcVoltageIntegrator,
                                           -VOLTAGE_LOOP_IREF_LIMIT_A,
                                           VOLTAGE_LOOP_IREF_LIMIT_A);
}

//*****************************************************************************
//
//! Inner dq current controller. Computes dq current errors and PI voltage
//! commands every switching period for closed-loop modes.
//!
//! \return None.
//
//*****************************************************************************
void runDqCurrentControllerCla(void) {
    float idRef;
    float iqRef;
    float vLimit;
    float omegaElec;
    float vdPi;
    float vqPi;
    float vdFf;
    float vqFf;
    uint16_t pllRequired;

    // Open-loop mode: no current control, zero all states
    if (controlMode == 0u) {
        idCurrentErr = 0.0f;
        iqCurrentErr = 0.0f;
        idIntegrator = 0.0f;
        iqIntegrator = 0.0f;
        vdCommand = 0.0f;
        vqCommand = 0.0f;
        return;
    }

    // If PLL is required but not locked, hold output at zero (safe state)
    pllRequired = ((angleSourceSelect == 1u) || (controlMode == 3u)) ? 1u : 0u;
    if ((pllRequired == 1u) && (pllLocked == 0u)) {
        idCurrentErr = 0.0f;
        iqCurrentErr = 0.0f;
        idIntegrator = 0.0f;
        iqIntegrator = 0.0f;
        vdCommand = 0.0f;
        vqCommand = 0.0f;
        return;
    }

    //
    // Select current references based on control mode:
    //   Mode 1: direct user references
    //   Mode 2: references from outer AC-voltage loop
    //   Mode 3: d-axis from DC-bus loop, q-axis forced to 0
    //
    if (controlMode == 2u) {
        idRef = idRefFromVoltageLoop;
        iqRef = iqRefFromVoltageLoop;
    } else if (controlMode == 3u) {
        idRef = idRefFromDcVoltageLoop;
        iqRef = 0.0f;
    } else {
        idRef = idRefCurrent;
        iqRef = iqRefCurrent;
    }

    idCurrentErr = idRef - idCurrentMeas;
    iqCurrentErr = iqRef - iqCurrentMeas;

    // Voltage command saturation limit: half the DC bus, floored and capped
    vLimit = 0.5f * dcBusVoltageMeas;
    if (vLimit < (0.5f * VDC_MIN_FOR_MODULATION_V))
        vLimit = 0.5f * VDC_MIN_FOR_MODULATION_V;
    if (vLimit > CURRENT_LOOP_VCMD_MAX_ABS_V)
        vLimit = CURRENT_LOOP_VCMD_MAX_ABS_V;

    // PI controller with anti-windup (integrator clamped to voltage limit)
    idIntegrator = clampFloatCla(idIntegrator + currentKi * controlPeriodSec * idCurrentErr, -vLimit, vLimit);
    iqIntegrator = clampFloatCla(iqIntegrator + currentKi * controlPeriodSec * iqCurrentErr, -vLimit, vLimit);

    vdPi = currentKp * idCurrentErr + idIntegrator;
    vqPi = currentKp * iqCurrentErr + iqIntegrator;

    // Voltage feedforward: adds measured grid voltage to reduce steady-state error
    if (pllLocked == 1u) {
        vdFf = CURRENT_LOOP_VOLTAGE_FF_GAIN * vdVoltageMeas;
        vqFf = CURRENT_LOOP_VOLTAGE_FF_GAIN * vqVoltageMeas;
    } else {
        vdFf = 0.0f;
        vqFf = 0.0f;
    }

    // Electrical frequency for cross-coupling decoupling (omega * L)
    if (pllRequired == 1u) {
        omegaElec = pllOmega;
    } else {
        if (controlPeriodSec > 0.0f)
            omegaElec = angleStep / controlPeriodSec;
        else
            omegaElec = pllOmegaNom;
    }

    // Final voltage command = PI output + feedforward + cross-coupling decoupling
    //   Decoupling: Vd -= wL*Iq, Vq += wL*Id (cancels rotational coupling)
    vdCommand = vdPi + vdFf - omegaElec * CURRENT_LOOP_DECOUPLING_L_H * iqCurrentMeas;
    vqCommand = vqPi + vqFf + omegaElec * CURRENT_LOOP_DECOUPLING_L_H * idCurrentMeas;
    vdCommand = clampFloatCla(vdCommand, -vLimit, vLimit);
    vqCommand = clampFloatCla(vqCommand, -vLimit, vLimit);
}

//*****************************************************************************
//
//! Update EPWM counter compare values of all phases in open-loop sine PWM
//! control mode based on current phase angles and modulation factor.
//!
//! \return None.
//
//*****************************************************************************
void updateOpenLoopSinePwmsCla(void) {
    updateIndividualOpenLoopSinePwmCla(myEPWM1_BASE, epwmAngles[0]);
    updateIndividualOpenLoopSinePwmCla(myEPWM2_BASE, epwmAngles[1]);
    updateIndividualOpenLoopSinePwmCla(myEPWM3_BASE, epwmAngles[2]);
}

//*****************************************************************************
//
//! Update EPWM duty cycles using closed-loop current controller output.
//! vd/vq are transformed back to abc phase commands and mapped to [0,1] duty.
//!
//! \return None.
//
//*****************************************************************************
void updateClosedLoopCurrentPwmsCla(void) {
    // Inverse Park transform: dq voltage commands -> alpha-beta frame
    float sinTheta = CLAsin(electricalAngle);
    float cosTheta = CLAsin(electricalAngle + PI * 0.5f);  // cos(x) = sin(x + pi/2)
    float vAlpha = vdCommand * cosTheta - vqCommand * sinTheta;
    float vBeta  = vdCommand * sinTheta + vqCommand * cosTheta;

    // Inverse Clarke transform: alpha-beta -> 3-phase voltages
    float vU = vAlpha;
    float vV = -0.5f * vAlpha + INV_CLARKE_SIN60 * vBeta;
    float vW = -0.5f * vAlpha - INV_CLARKE_SIN60 * vBeta;

    // Normalize phase voltages to [-1, +1] modulation index using DC bus
    float vBusHalf = 0.5f * dcBusVoltageMeas;
    if (vBusHalf < (0.5f * VDC_MIN_FOR_MODULATION_V))
        vBusHalf = 0.5f * VDC_MIN_FOR_MODULATION_V;

    float modU = clampUnitFloatCla(vU / vBusHalf);
    float modV = clampUnitFloatCla(vV / vBusHalf);
    float modW = clampUnitFloatCla(vW / vBusHalf);

    // Convert [-1, +1] modulation to [0, 1] duty and write to EPWM compare registers
    updateIndividualDutyPwmCla(myEPWM1_BASE, (modU + 1.0f) * 0.5f);
    updateIndividualDutyPwmCla(myEPWM2_BASE, (modV + 1.0f) * 0.5f);
    updateIndividualDutyPwmCla(myEPWM3_BASE, (modW + 1.0f) * 0.5f);
}

//*****************************************************************************
//
//! Update EPWM counter compare value based on current phase angle and
//! modulation factor.
//!
//! \param base is the EPWM base to update.
//! \param epwmIndividualAngle is the current EPWM phase angle.
//!
//! \return None.
//
//*****************************************************************************
void updateIndividualOpenLoopSinePwmCla(uint32_t base, float epwmIndividualAngle) {
    // Convert sine modulation to [0, 1] duty: duty = (m * sin(theta) + 1) / 2
    float duty = CLAdiv((modulationFactor * CLAsin(epwmIndividualAngle) + 1.0f), 2.0f);

    EPWM_setCounterCompareValue(base, EPWM_COUNTER_COMPARE_A, (uint16_t)(duty * epwmTimebasePeriod));
}

//*****************************************************************************
//
//! Update EPWM counter compare using an explicit duty command [0,1].
//!
//! \return None.
//
//*****************************************************************************
void updateIndividualDutyPwmCla(uint32_t base, float phaseDuty) {
    if (phaseDuty > 1.0f)
        phaseDuty = 1.0f;
    else if (phaseDuty < 0.0f)
        phaseDuty = 0.0f;

    EPWM_setCounterCompareValue(base, EPWM_COUNTER_COMPARE_A, (uint16_t)(phaseDuty * epwmTimebasePeriod));
}

//*****************************************************************************
//
//! Bound a scalar to [-1, 1] for normalized modulation commands.
//!
//! \return Saturated value.
//
//*****************************************************************************
float clampUnitFloatCla(float val) {
    if (val > 1.0f)
        return 1.0f;
    if (val < -1.0f)
        return -1.0f;
    return val;
}

//*****************************************************************************
//
//! Bound a scalar to user-provided limits.
//!
//! \return Saturated value.
//
//*****************************************************************************
float clampFloatCla(float val, float low, float high) {
    if (val > high)
        return high;
    if (val < low)
        return low;
    return val;
}
